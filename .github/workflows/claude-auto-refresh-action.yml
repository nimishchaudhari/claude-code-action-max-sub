name: Claude Code Assistant with Auto Token Refresh

on:
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  workflow_dispatch: # Allows manual triggering
  schedule:
    # Refresh token every 6 hours to prevent expiration
    - cron: "0 */6 * * *"

permissions:
  contents: write
  issues: write
  pull-requests: write
  id-token: write # Required for OIDC authentication

jobs:
  refresh-and-run-claude:
    # Only run if comment contains @claude or if it's a scheduled/manual run
    if: |
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@claude')) ||
      github.event_name == 'schedule' ||
      github.event_name == 'workflow_dispatch'

    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Refresh Claude OAuth Token
        id: refresh_token
        continue-on-error: true
        env:
          CLAUDE_ACCESS_TOKEN: ${{ secrets.CLAUDE_ACCESS_TOKEN }}
          CLAUDE_REFRESH_TOKEN: ${{ secrets.CLAUDE_REFRESH_TOKEN }}
          CLAUDE_EXPIRES_AT: ${{ secrets.CLAUDE_EXPIRES_AT }}
        run: |
          python - << 'EOF'
          import os
          import json
          import urllib.request
          import urllib.error

          def check_token_expired(expires_at):
              if not expires_at:
                  return True
              try:
                  import time
                  return time.time() >= float(expires_at) - 300  # Refresh 5 minutes before expiry
              except:
                  return True

          def refresh_token(refresh_token):
              url = "https://console.anthropic.com/v1/oauth/token"
              data = json.dumps({
                  "grant_type": "refresh_token",
                  "refresh_token": refresh_token,
                  "client_id": "9d1c250a-e61b-44d9-88ed-5944d1962f5e"
              }).encode('utf-8')
              
              req = urllib.request.Request(url, data=data)
              req.add_header('Content-Type', 'application/json')
              
              try:
                  with urllib.request.urlopen(req) as response:
                      result = json.loads(response.read().decode('utf-8'))
                      return result
              except urllib.error.HTTPError as e:
                  error_body = e.read().decode('utf-8')
                  raise Exception(f"HTTP {e.code}: {error_body}")

          # Get tokens from environment
          refresh_token_value = os.environ.get("CLAUDE_REFRESH_TOKEN")
          current_access_token = os.environ.get("CLAUDE_ACCESS_TOKEN")
          expires_at = os.environ.get("CLAUDE_EXPIRES_AT")

          if not refresh_token_value:
              raise Exception("CLAUDE_REFRESH_TOKEN not found in secrets")

          # Check if token needs refreshing
          if not check_token_expired(expires_at):
              print("‚úÖ Token is still valid, no refresh needed")
              if current_access_token and "GITHUB_OUTPUT" in os.environ:
                  with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                      f.write(f"access_token={current_access_token}\n")
                      f.write(f"expires_at={expires_at}\n")
                      f.write(f"token_refreshed=false\n")
              exit(0)

          print("üîÑ Refreshing Claude OAuth token...")

          try:
              # Refresh the token
              token_response = refresh_token(refresh_token_value)
              
              if "access_token" not in token_response:
                  raise Exception("No access token in response")
              
              access_token = token_response["access_token"]
              new_refresh_token = token_response.get("refresh_token", refresh_token_value)
              expires_in = token_response.get("expires_in", 28800)  # Default 8 hours
              
              # Calculate expiration timestamp
              import time
              new_expires_at = str(int(time.time() + expires_in))
              
              print("‚úì Token refreshed successfully")
              print(f"‚úì Token expires in {expires_in} seconds")
              
              # Output for GitHub Actions
              if "GITHUB_OUTPUT" in os.environ:
                  with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                      f.write(f"access_token={access_token}\n")
                      f.write(f"new_refresh_token={new_refresh_token}\n")
                      f.write(f"expires_at={new_expires_at}\n")
                      f.write(f"token_refreshed=true\n")
              
              # Mask the token in logs
              print(f"::add-mask::{access_token}")
              
          except Exception as e:
              print(f"‚ùå Error: {str(e)}")
              # Check if it's a Cloudflare error
              if "error code: 1010" in str(e):
                  print("‚ö†Ô∏è  OAuth token refresh is currently not available due to endpoint restrictions.")
                  print("‚ö†Ô∏è  Please use API key authentication instead or provide a valid access token.")
              exit(1)
          EOF

      # Update secrets using Python and pynacl
      - name: Update GitHub Secrets
        if: steps.refresh_token.outcome == 'success' && steps.refresh_token.outputs.token_refreshed == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ACCESS_TOKEN: ${{ steps.refresh_token.outputs.access_token }}
          REFRESH_TOKEN: ${{ steps.refresh_token.outputs.new_refresh_token }}
          EXPIRES_AT: ${{ steps.refresh_token.outputs.expires_at }}
        run: |
          # Install required Python packages
          pip install pynacl requests

          # Update secrets using Python
          python - << 'EOF'
          import os
          import json
          import requests
          from nacl import encoding, public

          # Setup
          token = os.environ['GITHUB_TOKEN']
          repo = os.environ['GITHUB_REPOSITORY']
          headers = {
              'Authorization': f'token {token}',
              'Accept': 'application/vnd.github.v3+json'
          }

          try:
              # Get public key for encrypting secrets
              key_response = requests.get(
                  f'https://api.github.com/repos/{repo}/actions/secrets/public-key',
                  headers=headers
              )
              key_response.raise_for_status()
              key_data = key_response.json()
              
              # Encrypt and update a secret
              def update_secret(name, value):
                  if not value or value == 'undefined':
                      return
                      
                  # Encrypt the value
                  public_key = public.PublicKey(
                      key_data['key'].encode("utf-8"), 
                      encoding.Base64Encoder()
                  )
                  sealed_box = public.SealedBox(public_key)
                  encrypted = sealed_box.encrypt(value.encode("utf-8"))
                  encrypted_value = encoding.Base64Encoder().encode(encrypted).decode("utf-8")
                  
                  # Update the secret
                  response = requests.put(
                      f'https://api.github.com/repos/{repo}/actions/secrets/{name}',
                      headers=headers,
                      json={
                          'encrypted_value': encrypted_value,
                          'key_id': key_data['key_id']
                      }
                  )
                  
                  if response.status_code in [201, 204]:
                      print(f'‚úì Updated {name}')
                  else:
                      print(f'Failed to update {name}: {response.status_code} - {response.text}')
                      raise Exception(f'Failed to update {name}')
              
              # Update all three secrets
              if os.environ.get('ACCESS_TOKEN'):
                  update_secret('CLAUDE_ACCESS_TOKEN', os.environ['ACCESS_TOKEN'])
              if os.environ.get('REFRESH_TOKEN'):
                  update_secret('CLAUDE_REFRESH_TOKEN', os.environ['REFRESH_TOKEN'])
              if os.environ.get('EXPIRES_AT'):
                  update_secret('CLAUDE_EXPIRES_AT', os.environ['EXPIRES_AT'])
                  
              print('‚úÖ All secrets updated successfully')
              
          except Exception as e:
              print(f'‚ùå Error updating secrets: {str(e)}')
              import traceback
              traceback.print_exc()
              exit(1)
          EOF

      # Only run Claude action if this was triggered by a comment
      - name: Run Claude Code Action (OAuth)
        if: (github.event_name == 'issue_comment' || github.event_name == 'pull_request_review_comment') && steps.refresh_token.outcome == 'success'
        uses: nimishchaudhari/claude-code-action-max-sub@main
        with:
          use_oauth: true
          claude_access_token: ${{ steps.refresh_token.outputs.access_token }}
          claude_refresh_token: ${{ steps.refresh_token.outputs.new_refresh_token || secrets.CLAUDE_REFRESH_TOKEN }}
          claude_expires_at: ${{ steps.refresh_token.outputs.expires_at }}
          anthropic_model: "claude-opus-4-20250514"

      # Fallback to API key if OAuth refresh failed
      - name: Run Claude Code Action (API Key Fallback)
        if: (github.event_name == 'issue_comment' || github.event_name == 'pull_request_review_comment') && steps.refresh_token.outcome == 'failure'
        uses: nimishchaudhari/claude-code-action-max-sub@main
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          anthropic_model: "claude-opus-4-20250514"

      # Log success for scheduled runs
      - name: Log Scheduled Refresh Success
        if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
        run: |
          echo "‚úÖ Scheduled token refresh completed successfully"
          echo "Next refresh will occur at the next scheduled time"
